p8105\_hw1\_bg2645
================
Bing Bing Guo
9/18/2019

Problem 1

``` r
##create dataframe containing 4 variables# 

hw1_df = tibble(
  norm_samp = rnorm(8),
  vec_logical = norm_samp > 0,
  vec_char = c("apple", "banana","kiwi", "orange", "peach", "cherry", "lime", "lemon"),
  vec_factor = factor(c("one", "one", "two", "two","two", "three", "three", "three"))
)

##take the mean of each variable in the dataframe#
mean(pull(hw1_df, norm_samp))
```

    ## [1] 0.494099

``` r
mean(pull(hw1_df, vec_logical))
```

    ## [1] 0.875

``` r
mean(pull(hw1_df, vec_char))
```

    ## Warning in mean.default(pull(hw1_df, vec_char)): argument is not numeric or
    ## logical: returning NA

    ## [1] NA

``` r
mean(pull(hw1_df, vec_factor))
```

    ## Warning in mean.default(pull(hw1_df, vec_factor)): argument is not numeric
    ## or logical: returning NA

    ## [1] NA

``` r
##you are able to take the mean for norm_samp and vec_logical, however you are unable to take the mean for vec_char and vec_factor# 


as.numeric(pull(hw1_df, vec_logical))
```

    ## [1] 1 0 1 1 1 1 1 1

``` r
as.numeric(pull(hw1_df, vec_char))
```

    ## Warning: NAs introduced by coercion

    ## [1] NA NA NA NA NA NA NA NA

``` r
as.numeric(pull(hw1_df, vec_factor))
```

    ## [1] 1 1 3 3 3 2 2 2

``` r
##You cannot convert characters into numeric, which is why the the character variable resulted in "NA" conversion and thus you cannot take the mean. However, for the logical and factor variables it was able to convert into numeric values. For the logical variable it was able to convert True into 1 and False into 0, and converted the different factor levels into numbers ("one" converted to 1, "two" converted to 3, "three" converted to 2) and thus you are now able to take the mean. 
```

``` r
as.numeric(pull(hw1_df, vec_logical))*(pull(hw1_df, norm_samp))

as.factor(pull(hw1_df, vec_logical))*(pull(hw1_df, norm_samp))
  
as.numeric(as.factor(pull(hw1_df, vec_logical)))*(pull(hw1_df, norm_samp))  
```

Problem 2

``` r
# create dataframe #
set.seed(1234)

plot_df = tibble(
  x = rnorm(500),
  y = rnorm(500),
  vec_logical_2 = x + y > 1,
  vec_numeric_2 = as.numeric(vec_logical_2), 
  vec_factor_2 = as.factor(vec_logical_2)
)
```

*There were 500 and 5 in the dataset *The mean of the sample is
0.0018388 *The median of the sample is -0.0207073 *The standard
deviation of the sample is 1.0348139 \*The proportion of cases for which
x+y\>1 is 0.232

``` r
##create a scatter plot of y vs x, color logical variable # 

ggplot(plot_df, aes(y = y, x = x, color=vec_logical_2)) + geom_point()
```

![](p8105_hw1_bg2645_files/figure-gfm/unnamed-chunk-4-1.png)<!-- -->

``` r
ggsave("scatterplot1.pdf", plot = last_plot(), height = 4, width = 6)

#create a scatter plot of y vs x, color numeric variable# 
ggplot(plot_df, aes(y = y, x = x, color=vec_numeric_2)) + geom_point()
```

![](p8105_hw1_bg2645_files/figure-gfm/unnamed-chunk-4-2.png)<!-- -->

``` r
#create a scatter plot of y vs x, color factor variable# 
ggplot(plot_df, aes(y = y, x = x, color=vec_factor_2)) + geom_point()
```

![](p8105_hw1_bg2645_files/figure-gfm/unnamed-chunk-4-3.png)<!-- -->

Plot 1 and plot 3 have the same color scales as they are both coloring
True/False values, however plot 2 has a different color scale as it is
now coloring a numeric variable and thus coloring based on 0 or 1, which
is why there are only two colors shown instead of a gradient per the
key. This is becasue the numeric variable was created by coercing the
logical vector, thus turning the Yes and No into 0 and 1. Plot 3 has the
same color scales as plot 1, since the factor vector was created by
coercing the logical vector and thus for bot variables the values are
still in True/False.
